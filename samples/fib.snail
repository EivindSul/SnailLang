function fib(n) {
    --- 
    Initialize a pattern match for n.
    Think of the question mark as "What is n?"
    You could also not specify the type, but this may error.

    The Arrow after the question mark tells snail what to do with the value returned.
    It can be assigned to a variable, or put as an argument in a function.
    --- 
    int:n? -> function(ans) { return ans } :
    0 -> 1,
    1 -> 1,
    --- 
    Underscore means any match, but takes a type.
    Whitespace is ignored, so you can easiliy make the code readable and pretty.
    ---
    _ -> 
    fib(n - 1) + fib(n - 2)
    --- 
    A period signifies that the pattern match is done.
    Think of it as a sentence that answers the question from before.

    If nothing follows the period, it may be omitted.
    ---
    .
}

-- Without the comments.
function fib(n) {
    int:n? -> function(ans) { return ans } :
    0 -> 1,
    1 -> 1,
    _ -> 
    fib(n - 1) + fib(n - 2)
    .
}

-- With assignment instead of callback
function fib(n) {
    int:n? -> local ans :
    0 -> 1,
    1 -> 1,
    _ -> 
    fib(n - 1) + fib(n - 2)
    .
    return ans
}
---
What happens if someone passes a non-int?
You can make more cases using periods!
There can even be code between if you like,
as it is just a separate pattern match block.
---
function fib(n) {
    int:n? -> local ans :
    0 -> 1,
    1 -> 1,
    _ -> 
    fib(n - 1) + fib(n - 2)
    .
    --- 
    A pattern pointing to a value like this acts as a shorthand for "return 0".
    --- 
    _:n? -> 0
    .
    return ans
}
---
Or do the non-int pattern match first!
---
function fib(n) {
    !int:n? -> function(){ return 0 } .
    int:n? -> function(ans){ return ans }  :
    0 -> 1,
    1 -> 1,
    _ -> 
    fib(n - 1) + fib(n - 2)
}
